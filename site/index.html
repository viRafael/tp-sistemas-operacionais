<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Escalonamento - Algoritmos CAV</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .visualization-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .section-title {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: #4a5568;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .task-form {
            margin-bottom: 25px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #4a5568;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .btn-compare {
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
            width: 100%;
            margin-top: 10px;
        }

        .task-list {
            margin-bottom: 20px;
        }

        .task-item {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-info {
            flex: 1;
        }

        .task-name {
            font-weight: bold;
            color: #2d3748;
        }

        .task-details {
            font-size: 0.9rem;
            color: #718096;
            margin-top: 5px;
        }

        .task-score {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .algorithm-selector {
            margin-bottom: 20px;
        }

        .algorithm-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .algorithm-checkbox {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            transition: all 0.3s;
            cursor: pointer;
        }

        .algorithm-checkbox:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .algorithm-checkbox.selected {
            border-color: #667eea;
            background: #e6fffa;
        }

        .algorithm-checkbox input {
            margin-right: 8px;
        }

        .comparison-mode {
            background: #e6fffa;
            border: 2px solid #48bb78;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .comparison-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .algorithm-result {
            background: #f7fafc;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #667eea;
        }

        .algorithm-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2d3748;
        }

        .timeline {
            margin-bottom: 15px;
        }

        .timeline-container {
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 15px;
            overflow-x: auto;
        }

        .timeline-scale {
            display: flex;
            margin-bottom: 10px;
            font-size: 0.8rem;
            color: #718096;
        }

        .timeline-tick {
            flex: 1;
            text-align: center;
            border-right: 1px solid #e2e8f0;
            padding: 5px;
            min-width: 30px;
        }

        .timeline-bar {
            display: flex;
            margin-bottom: 8px;
            align-items: center;
            height: 35px;
        }

        .task-label {
            width: 60px;
            font-size: 0.7rem;
            font-weight: bold;
            margin-right: 10px;
        }

        .task-execution {
            height: 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .task-execution:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .task-a { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); }
        .task-b { background: linear-gradient(135deg, #4ecdc4 0%, #26d0ce 100%); }
        .task-c { background: linear-gradient(135deg, #45b7d1 0%, #2980b9 100%); }
        .task-d { background: linear-gradient(135deg, #f9ca24 0%, #f0932b 100%); }

        .algorithm-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #718096;
        }

        .comparison-table {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            overflow-x: auto;
        }

        .comparison-table table {
            width: 100%;
            border-collapse: collapse;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .comparison-table th {
            background: #f7fafc;
            font-weight: bold;
            color: #4a5568;
        }

        .best-result {
            background: #c6f6d5 !important;
            font-weight: bold;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                position: relative;
            }
        }

        @media (max-width: 768px) {
            .comparison-results {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .algorithm-grid {
                grid-template-columns: 1fr;
            }
        }

        .single-result {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .execution-log {
            max-height: 200px;
            overflow-y: auto;
            background: #f7fafc;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚗 Simulador de Escalonamento CAV</h1>
            <p>Comparação de Algoritmos para Carros Autônomos Conectados</p>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <h3 class="section-title">Configuração</h3>
                
                <div class="algorithm-selector">
                    <label><strong>Algoritmos para Simular:</strong></label>
                    <div class="algorithm-grid">
                        <div class="algorithm-checkbox" onclick="toggleAlgorithm('pontuacao')">
                            <input type="checkbox" id="alg-pontuacao" checked>
                            <label>Pontuação</label>
                        </div>
                        <div class="algorithm-checkbox" onclick="toggleAlgorithm('fifo')">
                            <input type="checkbox" id="alg-fifo">
                            <label>FIFO</label>
                        </div>
                        <div class="algorithm-checkbox" onclick="toggleAlgorithm('roundrobin')">
                            <input type="checkbox" id="alg-roundrobin">
                            <label>Round Robin</label>
                        </div>
                        <div class="algorithm-checkbox" onclick="toggleAlgorithm('prioridade')">
                            <input type="checkbox" id="alg-prioridade">
                            <label>Prioridade</label>
                        </div>
                        <div class="algorithm-checkbox" onclick="toggleAlgorithm('prioridadePreemptivo')">
                            <input type="checkbox" id="alg-prioridadePreemptivo">
                            <label>Prioridade Preemptivo</label>
                        </div>
                        <div class="algorithm-checkbox" onclick="toggleAlgorithm('edf')">
                            <input type="checkbox" id="alg-edf">
                            <label>EDF</label>
                        </div>
                    </div>
                </div>
                
                <div class="task-form">
                    <h4>Adicionar Tarefa:</h4>
                    <div class="form-group">
                        <label for="taskName">Nome:</label>
                        <input type="text" id="taskName" placeholder="Ex: Detecção de Obstáculo">
                    </div>
                    <div class="form-group">
                        <label for="taskDuration">Duração (s):</label>
                        <input type="number" id="taskDuration" min="1" value="5">
                    </div>
                    <div class="form-group">
                        <label for="taskPriority">Prioridade (1-10):</label>
                        <input type="number" id="taskPriority" min="1" max="10" value="5">
                    </div>
                    <div class="form-group">
                        <label for="taskArrival">Tempo de Chegada:</label>
                        <input type="number" id="taskArrival" min="0" value="0">
                    </div>
                    <div class="form-group">
                        <label for="taskDeadline">Deadline:</label>
                        <input type="number" id="taskDeadline" min="1" value="50">
                    </div>
                    <button class="btn" onclick="addTask()">Adicionar</button>
                    <button class="btn btn-secondary" onclick="loadDefaultTasks()">Exemplo</button>
                </div>

                <div class="form-group">
                    <label for="quantum">Quantum (s):</label>
                    <input type="number" id="quantum" min="1" value="2">
                </div>

                <button class="btn btn-compare" onclick="runComparison()">🔄 Executar Comparação</button>
                <button class="btn btn-danger" onclick="clearTasks()">Limpar</button>

                <div class="task-list" id="taskList">
                    <h4>Tarefas:</h4>
                    <div id="tasks"></div>
                </div>
            </div>

            <div class="visualization-panel">
                <h3 class="section-title">Resultados da Simulação</h3>
                <div id="comparisonMode" class="comparison-mode" style="display: none;">
                    <strong>🔄 Modo Comparação Ativado</strong><br>
                    Comparando múltiplos algoritmos com as mesmas tarefas
                </div>
                <div id="results"></div>
            </div>
        </div>

        <div id="comparisonTable" class="comparison-table" style="display: none;">
            <h3 class="section-title">Tabela Comparativa</h3>
            <div id="tableContent"></div>
        </div>
    </div>

    <script>
        let tasks = [];
        let selectedAlgorithms = ['pontuacao'];
        let taskColors = ['task-a', 'task-b', 'task-c', 'task-d'];

        class Task {
            constructor(name, duration, priority, arrivalTime, deadline) {
                this.name = name;
                this.duration = duration;
                this.priority = priority;
                this.arrivalTime = arrivalTime;
                this.deadline = deadline || 4294967295; // 2^32 - 1
                this.remainingTime = duration;
                this.score = priority === 1 ? 10000 : (2 * duration) / (7 * priority);
                this.waitTime = 0;
                this.completed = false;
                this.startTime = 0;
                this.finishTime = 0;
            }

            reset() {
                this.remainingTime = this.duration;
                this.waitTime = 0;
                this.completed = false;
                this.startTime = 0;
                this.finishTime = 0;
            }
        }

        function toggleAlgorithm(algorithm) {
            const checkbox = document.getElementById(`alg-${algorithm}`);
            const container = checkbox.parentElement;
            
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
                container.classList.add('selected');
                if (!selectedAlgorithms.includes(algorithm)) {
                    selectedAlgorithms.push(algorithm);
                }
            } else {
                container.classList.remove('selected');
                selectedAlgorithms = selectedAlgorithms.filter(alg => alg !== algorithm);
            }
            
            // Ensure at least one algorithm is selected
            if (selectedAlgorithms.length === 0) {
                checkbox.checked = true;
                container.classList.add('selected');
                selectedAlgorithms.push(algorithm);
            }
        }

        function addTask() {
            const name = document.getElementById('taskName').value;
            const duration = parseInt(document.getElementById('taskDuration').value);
            const priority = parseInt(document.getElementById('taskPriority').value);
            const arrivalTime = parseInt(document.getElementById('taskArrival').value);
            const deadline = parseInt(document.getElementById('taskDeadline').value);

            if (!name || !duration || !priority) {
                alert('Por favor, preencha todos os campos obrigatórios!');
                return;
            }

            const task = new Task(name, duration, priority, arrivalTime, deadline);
            tasks.push(task);
            
            // Clear form
            document.getElementById('taskName').value = '';
            document.getElementById('taskDuration').value = '5';
            document.getElementById('taskPriority').value = '5';
            document.getElementById('taskArrival').value = '0';
            document.getElementById('taskDeadline').value = '50';
            
            updateTaskList();
        }

        function loadDefaultTasks() {
            tasks = [
                new Task("Detecção de Obstáculo", 6, 5, 0, 20),
                new Task("Planejamento de Rota", 7, 1, 8, 30),
                new Task("Manutenção de Velocidade", 1, 7, 20, 40),
                new Task("Comunicação com Infraestrutura", 3, 3, 20, 50)
            ];
            updateTaskList();
        }

        function clearTasks() {
            tasks = [];
            updateTaskList();
            document.getElementById('results').innerHTML = '';
            document.getElementById('comparisonTable').style.display = 'none';
            document.getElementById('comparisonMode').style.display = 'none';
        }

        function updateTaskList() {
            const tasksDiv = document.getElementById('tasks');
            tasksDiv.innerHTML = '';
            
            tasks.forEach((task, index) => {
                const taskDiv = document.createElement('div');
                taskDiv.className = 'task-item';
                taskDiv.innerHTML = `
                    <div class="task-info">
                        <div class="task-name">${task.name}</div>
                        <div class="task-details">
                            D: ${task.duration}s | P: ${task.priority} | C: ${task.arrivalTime}s | DL: ${task.deadline}s
                        </div>
                    </div>
                    <div class="task-score">${task.score.toFixed(1)}</div>
                `;
                tasksDiv.appendChild(taskDiv);
            });
        }

        function runComparison() {
            if (tasks.length === 0) {
                alert('Adicione pelo menos uma tarefa!');
                return;
            }

            if (selectedAlgorithms.length === 0) {
                alert('Selecione pelo menos um algoritmo!');
                return;
            }

            const quantum = parseInt(document.getElementById('quantum').value);
            const results = {};

            // Run each selected algorithm
            selectedAlgorithms.forEach(algorithm => {
                // Reset all tasks
                tasks.forEach(task => task.reset());
                
                results[algorithm] = runAlgorithm(algorithm, tasks, quantum);
            });

            displayResults(results);
        }

        function runAlgorithm(algorithm, taskList, quantum) {
            const executionResults = [];
            let executionQueue = [];
            let arrivalQueue = [...taskList].sort((a, b) => a.arrivalTime - b.arrivalTime);
            let currentTime = 0;
            let overhead = 0;
            let log = [];
            let contextSwitches = 0;

            while (executionQueue.length > 0 || arrivalQueue.length > 0) {
                // Remove completed tasks
                if (executionQueue.length > 0 && executionQueue[0].remainingTime === 0) {
                    const completedTask = executionQueue.shift();
                    completedTask.completed = true;
                    completedTask.finishTime = currentTime;
                    completedTask.waitTime = currentTime - completedTask.arrivalTime - completedTask.duration;
                    log.push(`✅ ${completedTask.name} finalizada`);
                }

                // Add arriving tasks
                while (arrivalQueue.length > 0 && arrivalQueue[0].arrivalTime <= currentTime) {
                    const arrivingTask = arrivalQueue.shift();
                    executionQueue.push(arrivingTask);
                    log.push(`📋 ${arrivingTask.name} chegou`);
                    
                    // Sort queue based on algorithm
                    sortQueue(executionQueue, algorithm);
                }

                // Execute task
                if (executionQueue.length > 0) {
                    const currentTask = executionQueue[0];
                    let executionTime;

                    switch (algorithm) {
                        case 'fifo':
                        case 'prioridade':
                            executionTime = currentTask.remainingTime;
                            break;
                        default:
                            executionTime = Math.min(currentTask.remainingTime, quantum);
                    }

                    if (currentTask.startTime === 0 && currentTask.remainingTime === currentTask.duration) {
                        currentTask.startTime = currentTime;
                    }

                    executionResults.push({
                        taskName: currentTask.name,
                        startTime: currentTime,
                        duration: executionTime,
                        taskIndex: taskList.indexOf(currentTask)
                    });

                    currentTask.remainingTime -= executionTime;
                    currentTime += executionTime;
                    log.push(`⚡ ${currentTask.name}: ${executionTime}s`);

                    // Handle preemption and context switch
                    if (currentTask.remainingTime > 0 && algorithm !== 'fifo' && algorithm !== 'prioridade') {
                        overhead += 1;
                        currentTime += 1;
                        contextSwitches++;
                        
                        // Special handling for pontuacao algorithm
                        if (algorithm === 'pontuacao') {
                            // Reapply pontuacao logic after each execution
                            executionQueue = handlePontuacaoQueue(executionQueue, quantum);
                        }
                    }
                } else {
                    currentTime += 1;
                }
            }

            const completedTasks = taskList.filter(t => t.completed);
            const avgWaitTime = completedTasks.length > 0 ? 
                completedTasks.reduce((sum, t) => sum + t.waitTime, 0) / completedTasks.length : 0;

            return {
                executionResults,
                totalTime: currentTime,
                avgWaitTime,
                overhead,
                contextSwitches,
                completedTasks: completedTasks.length,
                log
            };
        }

        function sortQueue(queue, algorithm) {
            switch (algorithm) {
                case 'fifo':
                    // No sorting needed, FIFO maintains arrival order
                    break;
                case 'prioridade':
                case 'prioridadePreemptivo':
                    queue.sort((a, b) => a.priority - b.priority);
                    break;
                case 'edf':
                    queue.sort((a, b) => a.deadline - b.deadline);
                    break;
                case 'pontuacao':
                    queue.forEach(task => {
                        if (task.priority === 1) task.score = 10000;
                    });
                    queue.sort((a, b) => b.score - a.score);
                    break;
                case 'roundrobin':
                    // Round robin doesn't sort, just rotates
                    break;
            }
        }

        function handlePontuacaoQueue(queue, quantum) {
            // First, handle critical tasks (priority 1)
            queue.forEach(task => {
                if (task.priority === 1) task.score = 10000;
            });
            
            // Sort by score
            queue.sort((a, b) => b.score - a.score);
            
            // If no critical tasks, prioritize short tasks
            if (queue.length > 0 && queue[0].score !== 10000) {
                for (let i = 0; i < queue.length; i++) {
                    if (queue[i].remainingTime < quantum) {
                        const shortTask = queue.splice(i, 1)[0];
                        queue.unshift(shortTask);
                        break;
                    }
                }
            }
            
            return queue;
        }

        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            const comparisonMode = document.getElementById('comparisonMode');
            const comparisonTable = document.getElementById('comparisonTable');
            
            const isComparison = Object.keys(results).length > 1;
            
            if (isComparison) {
                comparisonMode.style.display = 'block';
                resultsDiv.innerHTML = '<div class="comparison-results"></div>';
                const comparisonDiv = resultsDiv.querySelector('.comparison-results');
                
                Object.entries(results).forEach(([algorithm, result]) => {
                    const algorithmDiv = document.createElement('div');
                    algorithmDiv.className = 'algorithm-result';
                    algorithmDiv.innerHTML = createAlgorithmResult(algorithm, result);
                    comparisonDiv.appendChild(algorithmDiv);
                });
                
                displayComparisonTable(results);
            } else {
                comparisonMode.style.display = 'none';
                const algorithm = Object.keys(results)[0];
                const result = results[algorithm];
                resultsDiv.innerHTML = `<div class="single-result">${createAlgorithmResult(algorithm, result)}</div>`;
                comparisonTable.style.display = 'none';
            }
        }

        function createAlgorithmResult(algorithm, result) {
            const algorithmNames = {
                pontuacao: 'Pontuação',
                fifo: 'FIFO',
                roundrobin: 'Round Robin',
                prioridade: 'Prioridade',
                prioridadePreemptivo: 'Prioridade Preemptivo',
                edf: 'EDF'
            };

            return `
                <div class="algorithm-title">${algorithmNames[algorithm]}</div>
                <div class="timeline">
                    ${createTimeline(result.executionResults)}
                </div>
                <div class="algorithm-stats">
                    <div class="stat-item">
                        <div class="stat-value">${result.totalTime}</div>
                        <div class="stat-label">Tempo Total (s)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.avgWaitTime.toFixed(1)}</div>
                        <div class="stat-label">Tempo Médio de Espera (s)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.overhead}</div>
                        <div class="stat-label">Sobrecarga (s)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${result.completedTasks}</div>
                        <div class="stat-label">Tarefas Concluídas</div>
                    </div>
                </div>
                <div class="execution-log">
                    ${result.log.slice(-10).map(entry => `<div>${entry}</div>`).join('')}
                </div>
            `;
        }

        function createTimeline(executionResults) {
            if (executionResults.length === 0) return '<div>Nenhuma execução</div>';
            
            const maxTime = Math.max(...executionResults.map(r => r.startTime + r.duration));
            
            let html = '<div class="timeline-container">';
            
            // Scale
            html += '<div class="timeline-scale">';
            for (let i = 0; i <= Math.min(maxTime, 20); i++) {
                html += `<div class="timeline-tick">${i}</div>`;
            }
            if (maxTime > 20) html += `<div class="timeline-tick">...${maxTime}</div>`;
            html += '</div>';
            
            // Task bars
            const taskNames = [...new Set(tasks.map(t => t.name))];
            taskNames.forEach((taskName, index) => {

            const taskExecutions = executionResults.filter(r => r.taskName === taskName);
                html += '<div class="timeline-bar">';
                html += `<div class="task-label">${taskName.substring(0, 8)}...</div>`;
                
                let currentPos = 0;
                taskExecutions.forEach(execution => {
                    // Add gap if needed
                    if (execution.startTime > currentPos) {
                        const gapWidth = ((execution.startTime - currentPos) / Math.max(maxTime, 20)) * 100;
                        html += `<div style="width: ${gapWidth}%; height: 20px;"></div>`;
                    }
                    
                    const width = (execution.duration / Math.max(maxTime, 20)) * 100;
                    const colorClass = taskColors[index % taskColors.length];
                    html += `<div class="task-execution ${colorClass}" style="width: ${width}%;">${execution.duration}s</div>`;
                    currentPos = execution.startTime + execution.duration;
                });
                
                html += '</div>';
            });
            return html;
        }

        function displayComparisonTable(results) {
            const comparisonTable = document.getElementById('comparisonTable');
            const tableContent = document.getElementById('tableContent');
            
            // Find best results
            const metrics = ['totalTime', 'avgWaitTime', 'overhead', 'contextSwitches'];
            const bestResults = {};
            
            metrics.forEach(metric => {
                const values = Object.entries(results).map(([alg, res]) => ({
                    algorithm: alg,
                    value: res[metric]
                }));
                bestResults[metric] = values.reduce((best, current) => 
                    current.value < best.value ? current : best
                ).algorithm;
            });
            
            // Create table
            let tableHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Algoritmo</th>
                            <th>Tempo Total (s)</th>
                            <th>Tempo Médio de Espera (s)</th>
                            <th>Sobrecarga (s)</th>
                            <th>Mudanças de Contexto</th>
                            <th>Tarefas Concluídas</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            const algorithmNames = {
                pontuacao: 'Pontuação',
                fifo: 'FIFO',
                roundrobin: 'Round Robin',
                prioridade: 'Prioridade',
                prioridadePreemptivo: 'Prioridade Preemptivo',
                edf: 'EDF'
            };
            
            Object.entries(results).forEach(([algorithm, result]) => {
                tableHTML += '<tr>';
                tableHTML += `<td><strong>${algorithmNames[algorithm]}</strong></td>`;
                tableHTML += `<td class="${bestResults.totalTime === algorithm ? 'best-result' : ''}">${result.totalTime}</td>`;
                tableHTML += `<td class="${bestResults.avgWaitTime === algorithm ? 'best-result' : ''}">${result.avgWaitTime.toFixed(1)}</td>`;
                tableHTML += `<td class="${bestResults.overhead === algorithm ? 'best-result' : ''}">${result.overhead}</td>`;
                tableHTML += `<td class="${bestResults.contextSwitches === algorithm ? 'best-result' : ''}">${result.contextSwitches}</td>`;
                tableHTML += `<td>${result.completedTasks}</td>`;
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            tableContent.innerHTML = tableHTML;
            comparisonTable.style.display = 'block';
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial selected algorithm
            document.getElementById('alg-pontuacao').checked = true;
            document.querySelector('[onclick="toggleAlgorithm(\'pontuacao\')"]').classList.add('selected');
            
            // Load default tasks
            loadDefaultTasks();
        });
    </script>
</body>
</html>